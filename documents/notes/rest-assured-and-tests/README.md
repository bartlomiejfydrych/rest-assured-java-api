# üåêREST Assured i testy ‚Äì notatki

# üìëSpis tre≈õci

- [START ‚Äì rozpoczƒôcie pisania test√≥w](#start_writing_tests)
- [RequestSpecification](#request_specification)
- [RestAssured.filters()](#rest_assured_filters)
- [RequestSpecBuilder](#request_spec_builder)
- [RestAssured.enableLoggingOfRequestAndResponseIfValidationFails()](#enable_log_fail)
- [RecursiveComparisonConfiguration()](#assertj_recursive_comparison_configuration)

---

# üìùOpis

## üìÑSTART ‚Äì rozpoczƒôcie pisania test√≥w <a name="start_writing_tests"></a>

1. Zak≈Çadamy `konta` i inne `dostƒôpy`
    - W przypadku tego projektu zak≈Çadamy `konto` oraz zdobywamy `API key` oraz `token` na stronie **Trello**
    - Szczeg√≥≈Çy w `README` katalogu `üìÇtrello-configuration`
2. W katalogu `src/main/resources` tworzymy katalog `configs`, a w nim plik o nazwie `config.properties`  
   Wszelkie ustawienia projektu warto trzymaƒá i odczytywaƒá z osobnego pliku, aby nie musieƒá nic zmieniaƒá w samym kodzie.  
   Zapisujemy w nim takie rzeczy jak:
   ```properties
   # File config.properties - project variables
   
   # BASE URL
   baseUrl=https://api.trello.com/1
   baseUrlProtocol=https
   baseUrlSubdomain=api
   baseUrlDomain=trello
   baseUrlTLD=com
   baseUrlNumber=1
   ```
3. Sprawdzamy, czy mamy w `pom.xml` dodane dependecy o nazwie `Dotenv Java`
4. Otwieramy plik `.gitignore` i dopisujemy w nim:  
   ```ignore
   ### MY FILES

   # environment
   environment/.env
   ```
5. W g≈Ç√≥wnym katalogu projektu tworzymy katalog o nazwie `environment`
6. W nim tworzymy dwa pliki:  
   - `.env` (tutaj bƒôdziemy przechowywaƒá nasze prawdziwe zmienne)
   - `.env.example` (tutaj bƒôdzie pusty wz√≥r dostƒôpny na repozytorium)
7. W plikach `.env` definiujemy:  
   - Sekcjƒô na w≈ÇƒÖczanie log√≥w przy failach test√≥w oraz pokazywania log√≥w zawsze
   - Sekcjƒô na `API key` oraz `token`
   ```properties
   # File .env ‚Äì environment variables
    
   # LOGS MANAGEMENT
   LOGS_WHEN_FAIL=true/false
   LOGS_ALWAYS=true/false
    
   # TRELLO API KEY & TOKEN
   TRELLO_API_KEY=yourTrelloApiKey
   TRELLO_TOKEN=yourTrelloToken
   ```
8. W katalogu `src/main/java` tworzymy katalog o nazwie `configuration`
9. W katalogu `configuration` tworzymy plik java class o nazwie `Config.java`
10. W pliku `Config.java` dopisujemy nastƒôpujƒÖce rzeczy:  
    ```java
    package configuration;
    
    import io.github.cdimascio.dotenv.Dotenv;
    
    import java.io.IOException;
    import java.io.InputStream;
    import java.util.Optional;
    import java.util.Properties;
    
    public class Config {
    
        private static final Properties properties = new Properties();
        private static final Dotenv dotenv = Dotenv.load();
    
        // ----------------------------------------------------------
        // Method that loads a configuration file (config.properties)
        // ----------------------------------------------------------
    
        /*
        NOTE FOR ME:
        Mechanizm, kt√≥ry zapewni, ≈ºe plik z config.properties bƒôdzie wczytany tylko raz i p√≥≈∫niej re-u≈ºywany
        do wszystkich metod, kt√≥re pobierajƒÖ informacje z tego pliku konfiguracyjnego.
        */
    
        // Static initializer to load the configuration file
        static {
            try (InputStream inputStream = Config.class.getClassLoader().getResourceAsStream("configs/config.properties")) {
                if (inputStream == null) {
                    throw new IllegalStateException("Configuration file 'config.properties' not found");
                }
                properties.load(inputStream);
            } catch (IOException e) {
                throw new IllegalStateException("Error loading configuration file", e);
            }
        }
    
        // -----
        // Utils
        // -----
    
        // STRING
    
        // config.properties ‚Äì Utility method to get string property value with optional defaults
        private static String getConfigProperty(String key, String defaultValue) {
            return Optional.ofNullable(properties.getProperty(key))
                    .map(String::trim)
                    .orElse(defaultValue != null ? defaultValue : "ERROR: Missing required key from 'config.properties' file: " + key);
        }
    
        // .env ‚Äì Utility method to get string property value with optional defaults
        private static String getEnvProperty(String key, String defaultValue) {
            return Optional.ofNullable(dotenv.get(key))
                    .map(String::trim)
                    .orElse(defaultValue != null ? defaultValue : "ERROR: Missing required key from '.env' file: " + key);
        }
    
        // BOOLEAN
    
        // config.properties ‚Äì Utility method to get boolean property value with optional defaults
        private static boolean getConfigPropertyBoolean(String key, Boolean defaultValue) {
            return Optional.ofNullable(properties.getProperty(key))
                    .map(String::trim)
                    .map(Boolean::parseBoolean)
                    .orElseGet(() -> {
                        if (defaultValue != null) {
                            return defaultValue;
                        } else {
                            throw new IllegalStateException("ERROR: Missing required key from 'config.properties' file: " + key);
                        }
                    });
        }
    
        // .env ‚Äì Utility method to get boolean property value with optional defaults
        private static boolean getEnvPropertyBoolean(String key, Boolean defaultValue) {
            return Optional.ofNullable(dotenv.get(key))
                    .map(String::trim)
                    .map(Boolean::parseBoolean)
                    .orElseGet(() -> {
                        if (defaultValue != null) {
                            return defaultValue;
                        } else {
                            throw new IllegalStateException("ERROR: Missing required key from '.env' file: " + key);
                        }
                    });
        }
    
        // --------------------------------------------------------
        // config.properties ‚Äì Methods that retrieve data from file
        // --------------------------------------------------------
    
        // BASE URL
    
        // Get API base URL
        public static String getBaseUrl() {
            return getConfigProperty("baseUrl", "https://api.trello.com/1");
        }
    
        // Get API base URL Protocol
        public static String getBaseUrlProtocol() {
            return getConfigProperty("baseUrlProtocol", "https");
        }
    
        // Get API base URL Subdomain
        public static String getBaseUrlSubdomain() {
            return getConfigProperty("baseUrlSubdomain", "api");
        }
    
        // Get API base URL Domain
        public static String getBaseUrlDomain() {
            return getConfigProperty("baseUrlDomain", "trello");
        }
    
        // Get API base URL TLD
        public static String getBaseUrlTLD() {
            return getConfigProperty("baseUrlTLD", "com");
        }
    
        // Get API base URL Number
        public static String getBaseUrlNumber() {
            return getConfigProperty("baseUrlNumber", "1");
        }
    
        // -------------------------------------------
        // .env ‚Äì Methods that retrieve data from file
        // -------------------------------------------
    
        // LOGS MANAGEMENT
    
        // Get Logs when Fail
        public static boolean getLogsWhenFail() {
            return getEnvPropertyBoolean("LOGS_WHEN_FAIL", true);
        }
    
        // Get Logs when Fail
        public static boolean getLogsAlways() {
            return getEnvPropertyBoolean("LOGS_ALWAYS", false);
        }
    
        // TRELLO API KEY & TOKEN
    
        // Get Trello API key
        public static String getTrelloApiKey() {
            return getEnvProperty("TRELLO_API_KEY", null);
        }
    
        // Get Trello token
        public static String getTrelloToken() {
            return getEnvProperty("TRELLO_TOKEN", null);
        }
    }
    ```
11. W katalogu `src/main/java/configuration` tworzymy plik `BaseUrlBuilder`
12. W pliku `BaseUrlBuilder` piszemy budowanie naszego URL ze zmiennych konfiguracyjnych projektu:  
   ```java
   package configuration;
   
   public class BaseUrlBuilder {
   
       public static String buildBaseUrl() {
           return String.format("%s://%s.%s.%s/%s",
                   Config.getBaseUrlProtocol(),
                   Config.getBaseUrlSubdomain(),
                   Config.getBaseUrlDomain(),
                   Config.getBaseUrlTLD(),
                   Config.getBaseUrlNumber()
           );
       }
   }
   ```
13. W katalogu `src/test/java` tworzymy katalog package o nazwie `configuration`
14. W katalogu `src/test/java/configuration` tworzymy plik `RequestSpecConfig`  
    Dlaczego tutaj, a nie w `main`?  
    Poniewa≈º `REST Assured` jest u≈ºywane tylko do test√≥w i jego specyfikacja tak zaleca.  
    ≈ªeby obej≈õƒá to ograniczenie mo≈ºna te≈º w `pom.xml` usunƒÖƒá wiersz z `<scope>test</scope>`.
15. W pliku `RequestSpecConfig` piszemy naszƒÖ wsp√≥lnƒÖ konfiguracjƒô dla wszystkich request√≥w:
    ```java
    package configuration;
    
    import io.restassured.builder.RequestSpecBuilder;
    import io.restassured.http.ContentType;
    import io.restassured.specification.RequestSpecification;
    
    public class RequestSpecConfig {
    
        private static final RequestSpecification requestSpecification = new RequestSpecBuilder()
                .addQueryParam("key", Config.getTrelloApiKey())
                .addQueryParam("token", Config.getTrelloToken())
                .setBaseUri(BaseUrlBuilder.buildBaseUrl())
                .setContentType(ContentType.JSON)
                .build();
    
        public static RequestSpecification getRequestSpecification() {
            return requestSpecification;
        }
    }
    ```
16. W katalogu `src/test/java` tworzymy katalog o nazwie `base`
17. W katalogu `src/test/java/base` tworzymy plik o nazwie `TestBase.java`
18. W pliku `TestBase.java` tworzymy wstƒôpnƒÖ konfiguracjƒô:  
    ```java
    package base;
    
    import configuration.Config;
    import configuration.RequestSpecConfig;
    import io.restassured.RestAssured;
    import io.restassured.filter.log.RequestLoggingFilter;
    import io.restassured.filter.log.ResponseLoggingFilter;
    import io.restassured.specification.RequestSpecification;
    import org.junit.jupiter.api.BeforeAll;
    
    public class TestBase {
        // Object containing all request settings
        protected static RequestSpecification requestSpecificationCommon;
    
        @BeforeAll
        public static void setUpAll() {
    
            // LOGS
    
            // Always print in console all request and response data
            if (Config.getLogsAlways()) {
                RestAssured.filters(new RequestLoggingFilter(), new ResponseLoggingFilter());
            }
            // Only when test fail print in console all request and response data
            if (Config.getLogsWhenFail()) {
                RestAssured.enableLoggingOfRequestAndResponseIfValidationFails();
            }
    
            // OTHERS
    
            // Class that allows you to configure API requests in a readable and reusable way
            requestSpecificationCommon = RequestSpecConfig.getRequestSpecification();
        }
    }
    ```

---

## üìÑRequestSpecification <a name="request_specification"></a>

### **`RequestSpecification` w REST Assured ‚Äì co to jest?**

üîπ **`RequestSpecification`** to **interfejs** w bibliotece **REST Assured**, kt√≥ry pozwala na **konfigurowanie
i wielokrotne u≈ºywanie ustawie≈Ñ dla ≈ºƒÖda≈Ñ HTTP**. Dziƒôki niemu mo≈ºna **uniknƒÖƒá powtarzania kodu** w testach API.

### **Jak dzia≈Ça `RequestSpecification`?**
Zamiast ka≈ºdorazowego ustawiania nag≈Ç√≥wk√≥w, parametr√≥w i innych w≈Ça≈õciwo≈õci requestu w ka≈ºdym te≈õcie, mo≈ºna to zrobiƒá
**raz**, a potem u≈ºywaƒá w wielu miejscach.

#### **Przyk≈Çad bez `RequestSpecification` (duplikacja kodu)**
```java
given()
    .baseUri("https://api.example.com")
    .header("Authorization", "Bearer token123")
    .contentType(ContentType.JSON)
.when()
    .get("/users")
.then()
    .statusCode(200);
```
Je≈õli masz wiele test√≥w, musisz za ka≈ºdym razem powtarzaƒá te same ustawienia.

#### **Przyk≈Çad z `RequestSpecification` (lepsza organizacja kodu)**
```java
RequestSpecification requestSpec = new RequestSpecBuilder()
    .setBaseUri("https://api.example.com")
    .addHeader("Authorization", "Bearer token123")
    .setContentType(ContentType.JSON)
    .build();

given()
    .spec(requestSpec)
.when()
    .get("/users")
.then()
    .statusCode(200);
```
Tutaj konfiguracja requestu jest **zapisywana w `requestSpec`**, co sprawia, ≈ºe testy sƒÖ **czystsze i bardziej modu≈Çowe**.

### **Co mo≈ºna skonfigurowaƒá w `RequestSpecification`?**
‚úÖ **Nag≈Ç√≥wki (`Headers`)** ‚Äì np. `Authorization`, `Content-Type`  
‚úÖ **Parametry zapyta≈Ñ (`Query Parameters`)** ‚Äì np. `?key=value`  
‚úÖ **Cia≈Ço ≈ºƒÖdania (`Body`)** ‚Äì np. JSON dla metod `POST` czy `PUT`  
‚úÖ **Bazowy URL (`Base URI`)** ‚Äì np. `https://api.example.com`  
‚úÖ **≈öcie≈ºki (`Base Path`)** ‚Äì np. `/v1/users`  
‚úÖ **Pliki (`MultiPart Requests`)** ‚Äì np. `uploading files`

### **Jak tworzyƒá `RequestSpecification`?**
Do tworzenia specyfikacji u≈ºywa siƒô **klasy pomocniczej `RequestSpecBuilder`**, a na ko≈Ñcu wywo≈Çuje `.build()`, aby
utworzyƒá finalny obiekt `RequestSpecification`.

#### **Przyk≈Çad tworzenia `RequestSpecification`**
```java
RequestSpecification requestSpec = new RequestSpecBuilder()
    .setBaseUri("https://api.example.com")
    .setBasePath("/v1")
    .addQueryParam("lang", "en")
    .addHeader("Authorization", "Bearer token123")
    .setContentType(ContentType.JSON)
    .build();
```

### **Podsumowanie**
üìå **`RequestSpecification`** pomaga **uniknƒÖƒá powtarzania konfiguracji request√≥w** i sprawia, ≈ºe testy REST API sƒÖ
**bardziej czytelne, modu≈Çowe i ≈Çatwiejsze w utrzymaniu**.  
üìå **Mo≈ºna go u≈ºywaƒá z `RequestSpecBuilder`**, aby w ≈Çatwy spos√≥b definiowaƒá specyfikacjƒô ≈ºƒÖda≈Ñ.  
üìå **Dziƒôki niemu testy sƒÖ bardziej przejrzyste, kr√≥tsze i ≈Çatwiejsze w zarzƒÖdzaniu.** üöÄ

---

## üìÑRestAssured.filters() <a name="rest_assured_filters"></a>

### **`RestAssured.filters()` ‚Äì Co to jest i jak dzia≈Ça?**

#### üîπ **Co to jest?**
Metoda `RestAssured.filters()` w bibliotece **REST Assured** umo≈ºliwia dodawanie filtr√≥w do wszystkich ≈ºƒÖda≈Ñ HTTP, kt√≥re
sƒÖ wykonywane w ramach test√≥w API.

Filtry pozwalajƒÖ na **przechwytywanie, modyfikowanie i analizowanie** zar√≥wno **≈ºƒÖda≈Ñ (`Request`)**, jak
i **odpowiedzi (`Response`)**.

### **üîπ Mo≈ºliwo≈õci `RestAssured.filters()`**
Metoda ta przyjmuje **dowolnƒÖ liczbƒô obiekt√≥w implementujƒÖcych interfejs `Filter`**, co oznacza, ≈ºe mo≈ºemy dodaƒá kilka
filtr√≥w jednocze≈õnie.

#### **1Ô∏è‚É£ Logowanie request√≥w i response'√≥w (`RequestLoggingFilter` & `ResponseLoggingFilter`)**
##### **Opis**
Loguje szczeg√≥≈Çy **wysy≈Çanych zapyta≈Ñ HTTP** i **otrzymanych odpowiedzi**.

##### **Przyk≈Çad u≈ºycia**
```java
RestAssured.filters(new RequestLoggingFilter(), new ResponseLoggingFilter());
```
##### **Co siƒô stanie?**
Po uruchomieniu testu w konsoli zobaczysz logi requestu i odpowiedzi:
```
Request method: GET
Request URI: https://api.example.com/users
Request headers: Accept=*/*
Response status: 200
Response body: { "id": 1, "name": "John Doe" }
```

#### **2Ô∏è‚É£ FiltrujƒÖce requesty (`RequestFilter`)**
##### **Opis**
Pozwala **modyfikowaƒá ≈ºƒÖdanie** przed jego wys≈Çaniem, np. dynamicznie zmieniaƒá nag≈Ç√≥wki.

##### **Przyk≈Çad u≈ºycia**
```java
RestAssured.filters((requestSpec, responseSpec, ctx) -> {
    requestSpec.header("X-Custom-Header", "CustomValue");
    return ctx.next(requestSpec, responseSpec);
});
```
##### **Co siƒô stanie?**
Ka≈ºde ≈ºƒÖdanie API otrzyma dodatkowy nag≈Ç√≥wek:
```
X-Custom-Header: CustomValue
```

#### **3Ô∏è‚É£ FiltrujƒÖce odpowiedzi (`ResponseFilter`)**
##### **Opis**
Pozwala **modyfikowaƒá lub analizowaƒá odpowied≈∫**, np. logowaƒá b≈Çƒôdy.

##### **Przyk≈Çad u≈ºycia**
```java
RestAssured.filters((requestSpec, responseSpec, ctx) -> {
    var response = ctx.next(requestSpec, responseSpec);
    
    if (response.statusCode() >= 400) {
        System.out.println("Error Response: " + response.getBody().asString());
    }
    
    return response;
});
```
##### **Co siƒô stanie?**
Je≈õli serwer zwr√≥ci status **400+**, zobaczysz w konsoli szczeg√≥≈Çy b≈Çƒôdu.

#### **4Ô∏è‚É£ Kombinacja wielu filtr√≥w jednocze≈õnie**
Mo≈ºna dodaƒá kilka filtr√≥w naraz:
```java
RestAssured.filters(
    new RequestLoggingFilter(),
    new ResponseLoggingFilter(),
    (requestSpec, responseSpec, ctx) -> {
        System.out.println("Before request: " + requestSpec.getURI());
        return ctx.next(requestSpec, responseSpec);
    }
);
```

### **üîπ Podsumowanie**
üìå `RestAssured.filters()` umo≈ºliwia przechwytywanie i modyfikowanie request√≥w i response'√≥w.  
üìå Mo≈ºna u≈ºywaƒá gotowych filtr√≥w (`RequestLoggingFilter`, `ResponseLoggingFilter`) lub tworzyƒá w≈Çasne
(`RequestFilter`, `ResponseFilter`).  
üìå Przydatne do **logowania, analizy b≈Çƒôd√≥w i dynamicznej modyfikacji zapyta≈Ñ**. üöÄ

---

## üìÑRequestSpecBuilder <a name="request_spec_builder"></a>

### **üîπ Co to jest `RequestSpecBuilder`?**
`RequestSpecBuilder` to klasa w bibliotece **REST Assured**, kt√≥ra s≈Çu≈ºy do **konfigurowania request√≥w HTTP** w spos√≥b
modularny i wielokrotnego u≈ºytku.

Zamiast ka≈ºdorazowego powtarzania konfiguracji dla ka≈ºdego testu API, mo≈ºna stworzyƒá **jednƒÖ specyfikacjƒô
(`RequestSpecification`)**, a nastƒôpnie wielokrotnie jƒÖ u≈ºywaƒá.

### **üîπ G≈Ç√≥wne zalety `RequestSpecBuilder`**
‚úÖ **Unikanie powtarzania kodu** ‚Äì ca≈Ça konfiguracja request√≥w jest w jednym miejscu.  
‚úÖ **≈Åatwiejsze zarzƒÖdzanie testami** ‚Äì gdy zmieniajƒÖ siƒô parametry request√≥w, edytujesz tylko specyfikacjƒô.  
‚úÖ **Modularno≈õƒá** ‚Äì mo≈ºna tworzyƒá r√≥≈ºne specyfikacje dla r√≥≈ºnych czƒô≈õci API.

### **üîπ Jak dzia≈Ça `RequestSpecBuilder`?**
Najpierw tworzymy specyfikacjƒô requestu za pomocƒÖ `RequestSpecBuilder`, konfigurujemy jƒÖ, a nastƒôpnie wywo≈Çujemy
`.build()`, aby uzyskaƒá finalny obiekt `RequestSpecification`.

```java
RequestSpecification requestSpec = new RequestSpecBuilder()
    .setBaseUri("https://api.example.com")
    .setBasePath("/users")
    .addQueryParam("lang", "en")
    .addHeader("Authorization", "Bearer token123")
    .setContentType(ContentType.JSON)
    .build();
```
Teraz mo≈ºemy u≈ºywaƒá `requestSpec` w wielu testach:
```java
given()
    .spec(requestSpec)
.when()
    .get()
.then()
    .statusCode(200);
```

### **üîπ Pe≈Çna lista metod `RequestSpecBuilder`**
#### **1Ô∏è‚É£ Ustawienie bazowego URL (`setBaseUri`)**
```java
.setBaseUri("https://api.example.com")
```
üîπ Definiuje **g≈Ç√≥wny adres API**, do kt√≥rego bƒôdƒÖ kierowane wszystkie requesty.

#### **2Ô∏è‚É£ Ustawienie ≈õcie≈ºki bazowej (`setBasePath`)**
```java
.setBasePath("/v1/users")
```
üîπ Dodaje **domy≈õlnƒÖ ≈õcie≈ºkƒô** do bazowego URL.  
üîπ Przyk≈Çadowy efekt: `https://api.example.com/v1/users`

#### **3Ô∏è‚É£ Dodawanie parametr√≥w query (`addQueryParam`)**
```java
.addQueryParam("lang", "en")
.addQueryParam("sort", "asc")
```
üîπ Dodaje **parametry do zapytania** (`?lang=en&sort=asc`).  
üîπ Mo≈ºna je tak≈ºe dynamicznie zmieniaƒá w testach.

#### **4Ô∏è‚É£ Dodawanie parametr√≥w ≈õcie≈ºki (`addPathParam`)**
```java
.addPathParam("userId", "123")
```
üîπ U≈ºywane w przypadku **dynamicznych URL-i**, np.:
```java
given()
    .spec(requestSpec)
.when()
    .get("/{userId}")
```
üîπ Wygeneruje URL: `https://api.example.com/123`

#### **5Ô∏è‚É£ Dodawanie nag≈Ç√≥wk√≥w (`addHeader`)**
```java
.addHeader("Authorization", "Bearer token123")
.addHeader("Accept", "application/json")
```
üîπ Ustawia **nag≈Ç√≥wki HTTP**, np. tokeny autoryzacyjne.

#### **6Ô∏è‚É£ Ustawienie typu tre≈õci (`setContentType`)**
```java
.setContentType(ContentType.JSON)
```
üîπ Definiuje format danych requestu (`JSON`, `XML`, `TEXT`).

#### **7Ô∏è‚É£ Ustawienie cia≈Ça requestu (`setBody`)**
```java
.setBody("{ \"name\": \"John Doe\" }")
```
üîπ Wysy≈Ça dane w **metodach `POST`, `PUT`, `PATCH`**.

#### **8Ô∏è‚É£ Ustawienie czasu oczekiwania (`setConfig`)**
```java
.setConfig(RestAssured.config().httpClient(HttpClientConfig.httpClientConfig()
    .setParam(CoreConnectionPNames.CONNECTION_TIMEOUT, 5000)
    .setParam(CoreConnectionPNames.SO_TIMEOUT, 5000)))
```
üîπ Ustawia **timeouty** i inne opcje HTTP.

#### **9Ô∏è‚É£ Budowanie specyfikacji (`build`)**
```java
.build();
```
üîπ **Tworzy finalny obiekt `RequestSpecification`**, gotowy do u≈ºycia w testach.

### **üîπ Podsumowanie**
üìå **`RequestSpecBuilder`** pozwala konfigurowaƒá **bazowy URL, nag≈Ç√≥wki, parametry, body i inne ustawienia request√≥w**.  
üìå **Zwiƒôksza czytelno≈õƒá kodu**, eliminujƒÖc powtarzajƒÖce siƒô konfiguracje w testach API.  
üìå **Pozwala na wielokrotne u≈ºycie tej samej specyfikacji**, co sprawia, ≈ºe testy sƒÖ **modularne i ≈Çatwiejsze w utrzymaniu**. üöÄ

---

## üìÑRestAssured.enableLoggingOfRequestAndResponseIfValidationFails() <a name="enable_log_fail"></a>

üìå **Co robi ta metoda?**  
Metoda **`RestAssured.enableLoggingOfRequestAndResponseIfValidationFails();`** w≈ÇƒÖcza automatyczne logowanie ≈ºƒÖda≈Ñ
(**request**) i odpowiedzi (**response**) **tylko w przypadku, gdy asercja testowa zako≈Ñczy siƒô niepowodzeniem**.

### **üîπ Jak to dzia≈Ça?**
1. Je≈õli test przejdzie pomy≈õlnie ‚Üí **nie loguje requestu i response'u**.
2. Je≈õli test zako≈Ñczy siƒô b≈Çƒôdem (np. zwr√≥ci inny status HTTP lub inne dane) ‚Üí **wtedy loguje request i response**.

### **üîπ Przyk≈Çad u≈ºycia**
```java
import io.restassured.RestAssured;
import static io.restassured.RestAssured.given;
import static org.hamcrest.Matchers.equalTo;

public class TestExample {

    public static void main(String[] args) {

        // W≈ÇƒÖczenie logowania TYLKO gdy test nie przejdzie
        RestAssured.enableLoggingOfRequestAndResponseIfValidationFails();

        given()
            .baseUri("https://jsonplaceholder.typicode.com")
            .basePath("/posts/1")
        .when()
            .get()
        .then()
            .statusCode(200)  // Je≈õli zwr√≥ci np. 404, to zostanie zalogowany ca≈Çy request/response
            .body("title", equalTo("Niepoprawny tytu≈Ç"));  // Celowy b≈ÇƒÖd -> logowanie
    }
}
```
üí° Je≈õli test nie przejdzie, w konsoli zobaczysz np.:
```
Request method: GET
Request URI: https://jsonplaceholder.typicode.com/posts/1
Response status code: 200
Response body: { "userId": 1, "id": 1, "title": "s≈Çuszny tytu≈Ç", ... }
java.lang.AssertionError: JSON path title doesn't match. Expected: Niepoprawny tytu≈Ç, but was: s≈Çuszny tytu≈Ç
```
Natomiast je≈õli test przejdzie **bez b≈Çƒôdu**, nie zobaczysz ≈ºadnego loga.

### **üîπ Zalety tej metody**
‚úÖ **Redukuje ilo≈õƒá log√≥w** ‚Äì logi pojawiajƒÖ siƒô tylko, gdy sƒÖ potrzebne.  
‚úÖ **Pomaga w debugowaniu** ‚Äì od razu widzisz szczeg√≥≈Çy b≈Çƒôdnego requestu.  
‚úÖ **≈Åatwa implementacja** ‚Äì wystarczy **jedna linia kodu**.

### **üîπ Kiedy stosowaƒá?**
‚úî W **wiƒôkszo≈õci test√≥w API** jako domy≈õlne ustawienie.  
‚úî Gdy **nie chcesz za≈õmiecaƒá log√≥w** niepotrzebnymi requestami.  
‚úî Gdy testujesz **du≈ºe API** i wa≈ºne jest przejrzyste logowanie tylko b≈Çƒôd√≥w.

### **üîπ Alternatywy**
1Ô∏è‚É£ **Pe≈Çne logowanie request√≥w i response'√≥w zawsze:**
```java
RestAssured.filters(new RequestLoggingFilter(), new ResponseLoggingFilter());
```
‚û°Ô∏è Loguje **wszystkie ≈ºƒÖdania i odpowiedzi**, niezale≈ºnie od wyniku testu.

2Ô∏è‚É£ **Logowanie tylko request√≥w:**
```java
RestAssured.filters(new RequestLoggingFilter());
```

3Ô∏è‚É£ **Logowanie tylko response'√≥w:**
```java
RestAssured.filters(new ResponseLoggingFilter());
```

### **üîπ Podsumowanie**
- **RestAssured.enableLoggingOfRequestAndResponseIfValidationFails();** to **inteligentne logowanie**, kt√≥re w≈ÇƒÖcza siƒô
tylko w przypadku **niepowodzenia testu**.
- ≈öwietne rozwiƒÖzanie dla **czytelnych log√≥w i efektywnego debugowania** test√≥w API.
- Jest **zalecanƒÖ praktykƒÖ** w testach automatycznych REST Assured. üöÄ

---

## üìÑRecursiveComparisonConfiguration() <a name="assertj_recursive_comparison_configuration"></a>

### **`RecursiveComparisonConfiguration` ‚Äì Co to jest?**

`RecursiveComparisonConfiguration` to klasa z **AssertJ**, kt√≥ra pozwala na **rekurencyjne por√≥wnywanie obiekt√≥w**
w testach. Dziƒôki niej mo≈ºemy szczeg√≥≈Çowo kontrolowaƒá, jak dzia≈Ça por√≥wnywanie, np.:
- Pomijanie niekt√≥rych p√≥l,
- Ignorowanie r√≥≈ºnic w typach,
- Dostosowywanie sposobu por√≥wnywania kolekcji i map,
- Por√≥wnywanie p√≥l w spos√≥b niestandardowy.

### **üîπ Przyk≈Çad u≈ºycia:**
Za≈Ç√≥≈ºmy, ≈ºe mamy dwie instancje klasy `User`, kt√≥re chcemy por√≥wnaƒá:

#### **1Ô∏è‚É£ Standardowe por√≥wnanie (`equals()`)**
```java
User expectedUser = new User("Mateusz", "Tadla", "mtadla@example.com");
User actualUser = new User("Mateusz", "Tadla", "mtadla@example.com");

assertThat(actualUser).isEqualTo(expectedUser);
```
Je≈õli **obiekty sƒÖ identyczne**, test przejdzie. Ale je≈õli np. `User` ma inne ID, test siƒô wywali.

#### **2Ô∏è‚É£ Por√≥wnanie rekurencyjne (pomijajƒÖc `id`)**
```java
import org.assertj.core.api.recursive.comparison.RecursiveComparisonConfiguration;

RecursiveComparisonConfiguration config = new RecursiveComparisonConfiguration();
config.ignoreFields("id"); // Ignorujemy pole "id"

assertThat(actualUser)
    .usingRecursiveComparison(config)
    .isEqualTo(expectedUser);
```
‚úîÔ∏è **Dziƒôki temu test przejdzie, nawet je≈õli `id` jest inne!**

### **üîπ G≈Ç√≥wne mo≈ºliwo≈õci `RecursiveComparisonConfiguration`**
#### 1Ô∏è‚É£ **Ignorowanie p√≥l**
Mo≈ºesz pominƒÖƒá konkretne pola, np. `id`, `createdAt`:
```java
config.ignoreFields("id", "createdAt");
```

#### 2Ô∏è‚É£ **Ignorowanie p√≥l tylko w jednym obiekcie**
Je≈õli np. pole `timestamp` jest w `actualUser`, ale nie w `expectedUser`, mo≈ºesz je pominƒÖƒá:
```java
config.ignoreFieldsOfTypes(LocalDateTime.class);
```

#### 3Ô∏è‚É£ **Ignorowanie kolejno≈õci w kolekcjach**
```java
config.ignoreCollectionOrder();
```
‚úîÔ∏è Dziƒôki temu `[1,2,3]` i `[3,2,1]` bƒôdƒÖ uznane za **r√≥wne**.

#### 4Ô∏è‚É£ **Por√≥wnywanie p√≥l niestandardowo**
Mo≈ºesz okre≈õliƒá w≈Çasny spos√≥b por√≥wnywania np. `BigDecimal` (aby ignorowaƒá precyzjƒô dziesiƒôtnƒÖ):
```java
config.withComparatorForType(BigDecimal::compareTo, BigDecimal.class);
```

### **üîπ Przyk≈Çadowy test z `RecursiveComparisonConfiguration`**
```java
@Test
void shouldCompareUsersIgnoringId() {
    User expectedUser = new User("Mateusz", "Tadla", "mtadla@example.com");
    User actualUser = new User("Mateusz", "Tadla", "mtadla@example.com");
    actualUser.setId(999); // R√≥≈ºne ID

    RecursiveComparisonConfiguration config = new RecursiveComparisonConfiguration();
    config.ignoreFields("id"); // Ignorujemy ID

    assertThat(actualUser)
        .usingRecursiveComparison(config)
        .isEqualTo(expectedUser);
}
```
‚úîÔ∏è **Test przejdzie pomimo r√≥≈ºnicy w `id`!**

### **üîπ Podsumowanie**
| Mo≈ºliwo≈õƒá                                                        | Opis                                             |
|------------------------------------------------------------------|--------------------------------------------------|
| `ignoreFields("id")`                                             | Pomija konkretne pola                            |
| `ignoreFieldsOfTypes(LocalDateTime.class)`                       | Pomija pola okre≈õlonego typu                     |
| `ignoreCollectionOrder()`                                        | Ignoruje kolejno≈õƒá w listach i zbiorach          |
| `withComparatorForType(BigDecimal::compareTo, BigDecimal.class)` | Niestandardowe por√≥wnywanie dla okre≈õlonego typu |

Dziƒôki `RecursiveComparisonConfiguration` mo≈ºesz **uniknƒÖƒá problem√≥w z `equals()`**, dostosowaƒá spos√≥b por√≥wnywania
i **uniknƒÖƒá niepotrzebnych fail√≥w** w testach. üöÄüî•
